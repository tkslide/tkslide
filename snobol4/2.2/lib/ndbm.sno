* Generated by setuputil.sno setup.makeinclude() 12/05/2020 15:28:22
	NDBM_DL = "ndbm"
**=pea
**=sect NAME
**snobol4ndbm \- SNOBOL4 NDBM interface
**
**=sect SYNOPSIS
**=code
**-INCLUDE 'ndbm.sno'
**        dbhandle = DBM_OPEN(file,flags,mode)
**        DBM_CLOSE(dbhandle)
**        DBM_STORE(dbhandle,key,datum,flags)
**        datum = DBM_FETCH(dbhandle,key)
**        DBM_DELETE(dbhandle,key)
**        key = DBM_FIRSTKEY(dbhandle)
**        key = DBM_NEXTKEY(dbhandle)
**        DBM_ERROR(dbhandle)
**        DBM_CLEARERR(dbhandle)
**=ecode
**
**=sect DESCRIPTION
**"NDBM" (for New Data Base Management) is an industry standard fast
**hashed storage API first created in 4.3BSD, and included in the Unix
**98 (SUSv2) standard.  The original DBM API appeared in AT&T Research
**Unix Version 7, and only allowed access to a single file at a time.
**
**There are many different implementations of this API, including:
**
**=bull The original BSD 4.3 ndbm
**Based on AT&T dbm.
**Found in commercial Un*x offerings.
**
**=bull Berkeley DB v1 compatibility interface.
**Supplied with 4.4BSD based systems: (Free|Open|Net)BSD, MacOS X.
**
**=bull GNU DBM (GDBM)
**Found in Linux distributions
**(may require a DBM compatibility package to be installed).
**
**=bull SDBM, Ozan Yigit's Public Domain implementation of NDBM.
**Supplied with this distribution, and used as a last resort
**on Un*x systems (and by default on non Un*x systems).
**=cut
**=pea
**=item B<DBM_OPEN(>I<filename>,I<flags>,I<mode>)
**takes a filename (STRING), flags (either "R" for read-only, "W" for
**write access, or "CW" to create and write a new file), and a "mode"
**string, which defaults to "0666" (octal) and returns a database
**handle which can be passed to the remaining functions.
**=cut
	LOAD("DBM_OPEN(STRING,STRING,STRING)EXTERNAL", NDBM_DL)
**=pea
**=item B<DBM_CLOSE>
**closes the database file. B<DBM_CLOSE> I<MUST>
**be called to ensure that all your data is written.
**=cut
	LOAD("DBM_CLOSE(EXTERNAL)STRING", NDBM_DL)
**=pea
**=item B<DBM_STORE>
**takes a database handle, key and datum strings, and a flag (either
**B<DBM_INSERT> to insert a new pair, or fail if the key already exists,
**or B<DBM_REPLACE> to insert or replace existing data).  The key and
**datum strings may contain an arbitrary series of characters.
**=cut
	LOAD("DBM_STORE(EXTERNAL,STRING,STRING,INTEGER)INTEGER", NDBM_DL)
**=pea
**=item B<DBM_FETCH>
**returns the stored datum (if any) for the supplied key, or fails.
**=cut
	LOAD("DBM_FETCH(EXTERNAL,STRING)STRING", NDBM_DL)
**=pea
**=item B<DBM_DELETE>
**deletes the stored datum (if any) for the supplied key, or fails.
**=cut
	LOAD("DBM_DELETE(EXTERNAL,STRING)INTEGER", NDBM_DL)
**=pea
**=item B<DBM_FIRSTKEY>
**and subsequent calls to B<DBM_NEXTKEY>
**allow you to traverse all stored keys.  The keys will be returned in
**arbitrary order, and the routines will fail at the end of the
**traversal.
**=cut
	LOAD("DBM_FIRSTKEY(EXTERNAL)STRING", NDBM_DL)
	LOAD("DBM_NEXTKEY(EXTERNAL)STRING", NDBM_DL)
**=pea
**=item B<DBM_ERROR>
**is a predicate which succeeds if the database handle is valid
**and an I/O error has occurred on the file.
**=cut
	LOAD("DBM_ERROR(EXTERNAL)STRING", NDBM_DL)
**=pea
**=item B<DBM_CLEARERR>
**is a predicate which succeeds if if the database handle is valid, and has
**the side effect of clearing the I/O error flag.
**=cut
	LOAD("DBM_CLEARERR(EXTERNAL)STRING", NDBM_DL)
**=pea
**=sect FILES
**NDBM, GDBM, and SDBM create two files: I<filename>.dir and I<filename>.pag.
**Berkeley DB creates a single I<filename>.db file.
**
**=sect SEE ALSO
**B<snobol4sqlite3dbm>(3),
**B<ndbm>(3),
**B<dbopen>(3),
**B<gdbm>(3).
**
**=sect AUTHOR
**Philip L. Budne
**
**=sect BUGS
**Not safe for concurrent read and write. The B<snobol4sqlite3dbm>(3)
**interface achieves this portably using B<snobol4sqlite3>(3).
**
**Some implementations (classic NDBM and SDBM) place limits on the total
**size of key plus datum (typically slightly less than 1KB).
**
**NOTE: Some implementations (classic NDBM and SDBM) create sparse files
**which appear (to "ls -l") to be larger than they are (see "ls -s").
**Copying such files may cause the non-allocated blocks to be "filled"
**with zeroed disk blocks, and then the files really will be large!
**
**Only GDBM provides locking to eliminate the possibility of file corruption,
**or reading of incomplete data.
**
**GDBM locking sometimes fails on NFS mounted partitions
**but does not provide a way to disable locking.
**
**DBM databases accessed concurrently by multiple processes are
**traditionally (re)created from text files and used for fast disk-based
**read-only table lookups.  Programs which need to update the file
**generate a new temporary copy using a different name, and then rename
**the new file(s), so that the next reader gets the new copies (existing
**readers continue to see old data).
**=cut
**** funcs.sno:
*
* $Id: funcs.sno,v 1.1 2014-10-12 06:26:01 phil Exp $
*
* Phil Budne <phil@ultimate.com>
* December 3, 2005
*
* NDBM interface for CSNOBOL4

	DBM_INSERT = 0
	DBM_REPLACE = 1
******** end funcs.sno
**************** end ndbm.sno
