* Generated by setuputil.sno setup.makeinclude() 12/05/2020 15:28:21
	LOGIC_DL = "logic"
	LOAD("LOGIC(INTEGER,,)", LOGIC_DL)
**** funcs.sno:
*
* $Id: funcs.sno,v 1.4 2014-12-21 20:14:06 phil Exp $
*
* Phil Budne <phil@ultimate.com>
* January 21, 2002
*
* Catspaw SPITBOL compatible LOGIC() functions
* NOTE!!! BASE argument must be passed an explicit null string for default!!
*
LOGIC.DEFINE
**=pea
**=sect NAME
**snobol4logic \- bitwise logic and conversions for SNOBOL4
**=sect SYNOPSYS
**=code
**B<-INCLUDE 'logic.sno'>
**=ecode
**=sect DESCRIPTION
**=cut
	DEFINE("NOT(ARG)")
	DEFINE("AND(ARG1,ARG2)")
	DEFINE("OR(ARG1,ARG2)")
	DEFINE("XOR(ARG1,ARG2)")
	DEFINE("NAND(ARG1,ARG2)")
	DEFINE("NOR(ARG1,ARG2)")
**=pea
**For binary operations,
**either argument can be B<INTEGER> or B<STRING>
**(if both string, must be of same length).
**=item B<NOT(>I<arg>B<)>
**returns bitwise not (complement) of integer argument.
**=item B<AND(>I<arg1>,I<arg2>B<)>
**bitwise intersection.
**=item B<OR(>I<arg1>,I<arg2>B<)>
**bitwise union.
**=item B<XOR(>I<arg1>,I<arg2>B<)>
**bitwise exclusive or (equivalence).
**=item B<NAND(>I<arg1>,I<arg2>B<)>
**bitwise intersection (first argument complemented).
**=item B<NOR(>I<arg1>,I<arg2>B<)>
**bitwise union (first argument complemented).
**=cut
	DEFINE("UPLUS(ARG1,ARG2)")
	DEFINE("UMINUS(ARG1,ARG2)")
	DEFINE("UMUL(ARG1,ARG2)")
	DEFINE("UDIV(ARG1,ARG2)")
**=item B<UPLUS(>I<arg1>,I<arg2>B<)>
**unsigned addition.
**=item B<UMINUS(>I<arg1>,I<arg2>B<)>
**unsigned subtraction.
**=item B<UMUL(>I<arg1>,I<arg2>B<)>
**unsigned multiplication.
**=item B<UDIV(>I<arg1>,I<arg2>B<)>
**unsigned division.
**=cut
	DEFINE("SHL(ARG1,ARG2)")
	DEFINE("SHR(ARG1,ARG2)")
	DEFINE("SAR(ARG1,ARG2)")
	DEFINE("ROL(ARG1,ARG2)")
	DEFINE("ROR(ARG1,ARG2)")
**=pea
**=item B<SHL(>I<arg1>,I<arg2>B<)>
**shift left.
**=item B<SHR(>I<arg1>,I<arg2>B<)>
**shift right.
**=item B<SAR(>I<arg1>,I<arg2>B<)>
**arithmetic (signed) shift right.
**=item B<ROL(>I<arg1>,I<arg2>B<)>
**rotate left.
**=item B<ROR(>I<arg1>,I<arg2>B<)>
**rotate right.
**=cut
	DEFINE("HI(ARG)")
	DEFINE("IH(ARG)")
	DEFINE("DIB(ARG,BASE)")
	DEFINE("IDB(ARG,BASE)")
**=pea
**=item B<HI(>I<str>B<)>
**convert base 16 string to integer.
**=item B<IH(>I<int>B<)>
**convert integer to base16 string.
**=item B<DIB(>I<str>,I<n>B<)>
**convert base I<n> string to integer.
**=item B<IDB(>I<int>,I<n>B<)>
**convert integer to base I<n> string.
**=cut
							:(LOGIC.END)

NOT	NOT	= LOGIC(1,ARG)				:S(RETURN)F(FRETURN)
AND	AND	= LOGIC(2,ARG1,ARG2)			:S(RETURN)F(FRETURN)
OR	OR	= LOGIC(3,ARG1,ARG2)			:S(RETURN)F(FRETURN)
XOR	XOR	= LOGIC(4,ARG1,ARG2)			:S(RETURN)F(FRETURN)
NAND	NAND	= LOGIC(5,ARG1,ARG2)			:S(RETURN)F(FRETURN)
NOR	NOR	= LOGIC(6,ARG1,ARG2)			:S(RETURN)F(FRETURN)
UPLUS	UPLUS	= LOGIC(7,ARG1,ARG2)			:S(RETURN)F(FRETURN)
UMINUS	UMINUS	= LOGIC(8,ARG1,ARG2)			:S(RETURN)F(FRETURN)
UMUL	UMUL	= LOGIC(9,ARG1,ARG2)			:S(RETURN)F(FRETURN)
UDIV	UDIV	= LOGIC(10,ARG1,ARG2)			:S(RETURN)F(FRETURN)
SHL	SHL	= LOGIC(11,ARG1,ARG2)			:S(RETURN)F(FRETURN)
SHR	SHR	= LOGIC(12,ARG1,ARG2)			:S(RETURN)F(FRETURN)
SAR	SAR	= LOGIC(13,ARG1,ARG2)			:S(RETURN)F(FRETURN)
ROL	ROL	= LOGIC(14,ARG1,ARG2)			:S(RETURN)F(FRETURN)
ROR	ROR	= LOGIC(15,ARG1,ARG2)			:S(RETURN)F(FRETURN)
HI	HI	= LOGIC(16,CONVERT(ARG,'STRING'),'')	:S(RETURN)F(FRETURN)
IH	IH	= LOGIC(17,CONVERT(ARG,'INTEGER'),'')	:S(RETURN)F(FRETURN)
DIB	DIB	= LOGIC(16,CONVERT(ARG,'STRING'),BASE)	:S(RETURN)F(FRETURN)
IDB	IDB	= LOGIC(17,CONVERT(ARG,'INTEGER'),BASE)	:S(RETURN)F(FRETURN)

LOGIC.END
	CODE('LOGIC.DEFINE')
	CODE('LOGIC.END')

**=pea
**=sect COMPATIBILITY
**compatible with Catspaw SPITBOL LOGIC function.
**=sect SEE ALSO
**B<snobol4>(1)
**=sect AUTHOR
**Philip L. Budne
**=cut
******** end funcs.sno
**************** end logic.sno
