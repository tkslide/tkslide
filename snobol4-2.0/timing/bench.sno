* $Id: bench.sno,v 1.4 2014/12/12 21:50:44 phil Exp $
* benchmark program. run by "timing" shell script
* modified version of genc from CSNOBOL 1.4.1:
*	$oldId: genc.sno,v 1.63 2004/08/12 16:10:13 phil Exp $

	MIN_SEC = 15
	MAX_SEC = 60
	MIN_STMT = 100 * 1000000
	MAX_STMT = 200 * 1000000

	KSS = -1

	OUTPUT(.TTY, IO_FINDUNIT(),, '/dev/tty')
	TTY = 'Min runtime ' MIN_SEC 's.; Maximum: ' MAX_SEC 's.'

*
*	Translator for the "Macro Implementation of SNOBOL" (aka MAINBOL)
*	written in SIL (SNOBOL IMPLEMENTATION LANGUAGE) to `C'
*
*	Phil Budne	March 1991	
*	bootstrapped using CATSPAW "SPARC SPITBOL"
*
*	genc.spt -- generate C code

****************************************************************
*	environment

*	kill case folding, for speed
-CASE 0

	GCTIME = 0

	OUTPUT(.OUTPUT, 77,, "/dev/null")
	LOOPS = 0
	TDIV5 = -1

*	set TRIM, for SNOBOL4+
	&TRIM = 1

*	identify if mainbol or spitbol
	MAINBOL = IDENT(.NAME,"NAME") 1

*	faster matching (match only at POS(0))
	&ANCHOR = 1

****************************************************************
*	initialization


****************
*	process options, get input filename

	INLINE_DIR = "subr/"

	IND = HOST(3)
OPTLOOP	ARG = HOST(2,IND)				:F(NOFILE)
	ARG POS(0) '-'					:F(OPTEND)
	IND = IND + 1

*	inline mode -- used to create isnobol4.c
*		output subroutines to seperate files in inline_dir
* XXX add --inline_dir/-I option??
	INLINE = IDENT(ARG,'-i') 'yes'			:S(OPTLOOP)
	INLINE = IDENT(ARG,'--inline') 'yes'		:S(OPTLOOP)

*	output SIL end of line comments (OFF -- to make snobol4.c smaller)
	EOL_COMMENTS = IDENT(ARG,'-e') 'yes'		:S(OPTLOOP)
	EOL_COMMENTS = IDENT(ARG,'--eol-comments') 'yes' :S(OPTLOOP)

*	output block comments (OFF -- problems at end of functions)
	BLOCK_COMMENTS = IDENT(ARG,'-b') 'yes'		:S(OPTLOOP)
	BLOCK_COMMENTS = IDENT(ARG,'--block-comments') 'yes' :S(OPTLOOP)

*	un*x '# line' lines (OFF)
* XXX doesn't work for ops which output more than one line of C!!
* need to do all output via a function OL(STR) which outputs a #line
* for each line of output!!!
	POUND_LINE = IDENT(ARG,'-l') 'yes'		:S(OPTLOOP)
	POUND_LINE = IDENT(ARG,'--pound-line') 'yes'	:S(OPTLOOP)

	TERMINAL = 'genc.sno: unknown option ' ARG
* XXX give help?
	&CODE = 1					:(END)

OPTEND	SILPATH = ARG

****************
*	different I/O routines for now under MAINBOL!
	DIFFER(MAINBOL)					:S(MB1)

	INPUT(.INPUT,5,SILPATH)				:F(BADFILE)

*	call graph (for ordering files for inlining)
*	XXX only output if INLINING set?
*	OUTPUT(.CALLGRAPH,10,'callgraph')

*	output list of global procs (for data segment)
	OUTPUT(.PROC.H,11,'proc.h2')

*	output list of static procs (included later)
	OUTPUT(.STATIC.H,12,'static.h2')

*	dummy out freeze/thaw
	DEFINE("FREEZE(T)","RETURN")
	DEFINE("THAW(T)","RETURN")
							:(EIO)

**************** MAINBOL I/O

MB1
	INPUT(.INPUT,5,,SILPATH)			:F(BADFILE)

*	call graph (for ordering files for inlining)
*	XXX only output if INLINING set?
*	OUTPUT(.CALLGRAPH,10,,'callgraph')

*	output list of global procs (for data segment)
	OUTPUT(.PROC.H,11,,'proc.h2')

*	output list of static procs (included later)
	OUTPUT(.STATIC.H,12,,'static.h2')

EIO

****************************************************************
*	compile time switches

****************************************************************
*	tables

*	table of procedures (labels ref'd by RCALL or branched to from
*	another function) generated by gendep program
	ISPROC = TABLE(300)

*	table of procedures referenced from data (DESCRs)
	GLOBAL = TABLE(150)

****************
*	SIL operations to not generate code for!
*	DO NOT ADD LHERE!!

	NOCODE = TABLE(10)
	NOCODE<'EQU'> = 1
	NOCODE<'ARRAY'> = 1
	NOCODE<'BLOCK'> = 1
	NOCODE<'BUFFER'> = 1
	NOCODE<'STRING'> = 1
	NOCODE<'DESCR'> = 1
	NOCODE<'SPEC'> = 1
	NOCODE<'FORMAT'> = 1
	FREEZE(NOCODE)
*
****************************************************************
*	constants

	SP = ' '
	TAB = '	'
	WHITE = SP TAB
	NUL = ''
	COMMA = ','
	SEMI = ';'

	LP = '('
	RP = ')'

	BC = '/*'
	EC = '*/'
	BBC = '/********************************'

	UC = "ABCDEFGHIJLKMNOPQRSTUVWXYZ"
	LC = "abcdefghijlkmnopqrstuvwxyz"
	DIGS = "0123456789"
	OPERS = "*+-/"
	PUNCT = "_"

*	avoid runtime negation!
	M1 = -1

*	goto label prefix
	L_ = "L_"
*	function label prefix (none, since referenced from data)
	F_ =
*	function return type
	PROCTYPE = "int"

*	basic patterns
	TOK = BREAK(WHITE)
	TNUL = TOK | NUL
	WS = SPAN(WHITE)

	ID = ANY(UC) SPAN(UC DIGS)
	ARGP = SPAN(UC LC DIGS OPERS PUNCT) | NUL

****************************************************************
*	functions

****************
* change indent level, (re)set IND (indent)

	IND_ARR = ARRAY('0:6')
	IND_ARR<0> = ''

	IND_ARR<1> = SP SP SP SP
	IND_ARR<2> = TAB

	IND_ARR<3> = IND_ARR<2> IND_ARR<1>
	IND_ARR<4> = IND_ARR<2> IND_ARR<2>

	IND_ARR<5> = IND_ARR<4> IND_ARR<1>
	IND_ARR<6> = IND_ARR<4> IND_ARR<2>

	DEFINE("INDENTX(X)L")				:(EINDENTX)
INDENTX	ILEVEL = ILEVEL + X
*	XXX check for ILEVEL .LT. 0??

**	L = ILEVEL / 2
***	XXX index pre-initialized array?
**	IND = DUPL(TAB, L) DUPL(SP, 4 * (ILEVEL - 2 * L))
	IND = IND_ARR<ILEVEL>
							:(RETURN)
EINDENTX

	DEFINE("INDENT()")				:(EINDENT)
INDENT	INDENTX(1)					:(RETURN)
EINDENT

	DEFINE("UNINDENT()")				:(EUNINDENT)
UNINDENT
	INDENTX(M1)					:(RETURN)
EUNINDENT

****************
*	flush out end of block comment before emitting code!
	DEFINE("CFLUSH()")				:(ECFLUSH)
CFLUSH	IDENT(BLOCK)					:S(RETURN)
	BLOCK =
	OUTPUT = SP EC					:(RETURN)
ECFLUSH
*
****************
*	begin a procedure
	DEFINE("BPROC(NAME)STAT")			:(EBPROC)
BPROC	EPROC(NAME)
	CFLUSH()
	INPROC = NAME
	LLBL =
	IDENT(INLINE)					:S(BPROC2)
*	if inlining, open new file
	DIFFER(MAINBOL)					:S(MB99)
	OUTPUT(.OUTPUT,99,INLINE_DIR NAME)		:(BPROC2)
MB99	OUTPUT(.OUTPUT,99,,INLINE_DIR NAME)
BPROC2	STATIC = "static "
	STATIC = DIFFER(GLOBAL<NAME>)
	OUTPUT = STATIC PROCTYPE
	OUTPUT = F_ NAME '(retval)'
	INDENT()
	OUTPUT = IND 'ret_t retval;'
	UNINDENT()
	OUTPUT = '{'
	INDENT()
* for call depth tracing, top of function label
	OUTPUT = IND 'ENTRY(' NAME ')'
*	OLABEL = 1
	LIVE = 1					:(RETURN)
EBPROC

****************
*	end a proc; new proc in NAME

	DEFINE("EPROC(NAME)")				:(EEPROC)
EPROC	CFLUSH()
	IDENT(INPROC)					:S(RETURN)
	IDENT(NAME)					:S(EPROC1)
*	"fall into" next proc (if this is live code) !!
	IDENT(LIVE)					:S(EPROC2)
	OUTPUT = IND "/* FALL */"
	BRANCH(NAME)					:(EPROC2)

EPROC1	OUTPUT = IND 'PANIC("fell out of ' INPROC '"); /* SNH */'
EPROC2
*	OUTPUT = DIFFER(OLABEL) IND ';'
	UNINDENT()
	OUTPUT = IND '}'
	IDENT(INLINE)					:(RETURN)
*	if inlining close file
	ENDFILE(99)
	DETACH(.OUTPUT)					:(RETURN)
EEPROC

****************
*	output code for a "branch"
*	if branch leaves procedure -- do "PJRST" (call + return)!!
	DEFINE("BRANCH(BLBL)")				:(EBRANCH)
BRANCH	LIVE =
	DIFFER(BLBL,INPROC)				:S(NOT_SAME)
*	TERMINAL = '%branch to top in procedure ' INPROC
							:(DO_GOTO)
NOT_SAME
	IDENT( ISPROC< BLBL >)				:S(DO_GOTO)
*	output info for inlining
	CALLGRAPH = BLBL TAB INPROC
	OUTPUT = IND 'BRANCH(' F_ BLBL ')'		:(RETURN)
DO_GOTO	OUTPUT = IND 'goto ' L_ BLBL ';'		:(RETURN)
EBRANCH
*
****************
*	push/pop one or more variables
	DEFINE("XAPPLY(FN,N)I,L")
	XAPPP1 = LP BREAK(RP) . L RP
	XAPPP2 = BREAK(COMMA) . I COMMA			:(EXAPPLY)
XAPPLY	N XAPPP1					:F(XAPPLY1)
	L = L COMMA
XAPPLYL
*	TERMINAL = 'XAPPLYL ' L
	L XAPPP2 =					:F(RETURN)
	OUTPUT = IND FN LP I RP ';'			:(XAPPLYL)
XAPPLY1	OUTPUT = IND FN LP N RP ';'			:(RETURN)
EXAPPLY

****************
*	push/pop one or more variables (reverse order)
	DEFINE("XRAPPLY(FN,N)L")
	XRAPPP1 = LP BREAK(RP) . L RP
	XRAPPP2 = BREAK(COMMA) . I COMMA		:(EXRAPPLY)
XRAPPLY	N XRAPPP1					:F(XRAPPLY1)
XRAPPLYL
	L = L COMMA
	XRAPPLY2(FN,L)					:(RETURN)
XRAPPLY1
	OUTPUT = IND FN LP N RP ';'			:(RETURN)
EXRAPPLY

********
	DEFINE("XRAPPLY2(FN,L)I")			:(EXRAPPLY2)
XRAPPLY2
*	TERMINAL = "XRAPPLY2 " L
	L XRAPPP2 =					:F(RETURN)
	XRAPPLY2(FN,L)
	OUTPUT = IND FN LP I RP ';'			:(RETURN)
EXRAPPLY2


****************
* used by SELBRA and RCALL

* XXX if only one label use if()?! (happens twice)

	DEFINE("SELBRA(V,LL)N,L,I,PREVL")
	SELBRA_P1 = LP BREAK(RP) . L RP
	SELBRA_P2 = (ARGP . N) COMMA			:(ESELBRA)
SELBRA	LL SELBRA_P1					:F(FRETURN)
	L = L COMMA
	I = 0
	OUTPUT = IND 'switch (' V  ') {'
	INDENT()

	PREVL = 
*	top of loop
SELBRAL	L SELBRA_P2 =					:F(SELBRAE)
	I = I + 1
	IDENT(N)					:S(SELBRAL)
	IDENT(PREVL,N)					:S(SELBRAO)

*	new label, output old one
	DIFFER(PREVL) BRANCH(PREVL)
	PREVL = N

SELBRAO	UNINDENT()
	OUTPUT = IND 'case ' I ':'
	INDENT()					:S(SELBRAL)

*	no more tags; output last label (if non-null)
SELBRAE	DIFFER(PREVL) BRANCH(PREVL)

*	could fall thru
	LIVE = 1
	UNINDENT()
	OUTPUT = IND '}'				:(RETURN)
ESELBRA
*
****************
*	optimized 3-way compare -- (re)sets LIVE if missing a label!
*
	DEFINE("DOCMP3(X,Y,G,E,L)ELSE")			:(EDOCMP3)
DOCMP3	IDENT(L,G)					:S(DOCMPNE)
	IDENT(L)					:S(DOCMPE)
	IDENT(L,E)					:S(DOCMPLE)

	OUTPUT = IND 'if (' X ' < ' Y ')'
	INDENT()
	BRANCH(L)
	UNINDENT()
	IDENT(E)					:S(DOCMPG)
	IDENT(E,G)					:F(DOCMPE)
	ELSE = E

*	here to make else clause
DOCMPEL	OUTPUT = IND 'else'
	INDENT()
	BRANCH(ELSE)
	UNINDENT()					:(RETURN)

DOCMPLE	OUTPUT = IND 'if (' X ' <= ' Y ')'
	INDENT()
	BRANCH(L)
	UNINDENT()
	IDENT(G)					:S(DOCMPR)
	ELSE = G					:(DOCMPEL)

DOCMPNE	DOCMP2(X,Y,L,E)					:(RETURN)

DOCMPE	IDENT(E)					:S(DOCMPG)
	IDENT(G,E)					:S(DOCMPGE)
	OUTPUT = IND 'if (' X ' == ' Y ')'
	INDENT()
	BRANCH(E)
	UNINDENT()					:(DOCMPG)

DOCMPGE	OUTPUT = IND 'if (' X ' >= ' Y ')'
	INDENT()
	BRANCH(E)
	UNINDENT()					:(DOCMPD)

DOCMPG	IDENT(G)					:S(DOCMPD)
	(DIFFER(E) DIFFER(L))				:S(DOCMPG2)
* here with one (or more of L/E labels missing)
	OUTPUT = IND 'if (' X ' > ' Y ')'
	INDENT()
	BRANCH(G)
	UNINDENT()					:(DOCMPR)

* here with all labels present; no GT test needed; return dead code path
DOCMPG2	BRANCH(G)					:(RETURN)

*	done, check if all 3 labels present (dead code path)
DOCMPD	IDENT(G)					:S(DOCMPR)
	IDENT(E)					:S(DOCMPR)
	IDENT(L)					:S(DOCMPR)
*	all 3 labels present (and different)!, dead code path 
	LIVE =						:(RETURN)

*	one or more labels missing; live code path
DOCMPR	LIVE = 1					:(RETURN)
EDOCMP3
*
****************************************************************
*	two-way compare

	DEFINE("DOCMP2(X,Y,N,E)")			:(EDOCMP2)
DOCMP2	IDENT(E)					:S(DOCMP22)
	OUTPUT = IND 'if (' X ' == ' Y ')'
	INDENT()
	BRANCH(E)
	UNINDENT()
	IDENT(N)					:S(DOCMP2L)
	OUTPUT = IND 'else'
	INDENT()
	BRANCH(N)
	UNINDENT()					:(RETURN)

DOCMP22	IDENT(N)					:S(DOCMP2L)
	OUTPUT = IND 'if (' X ' != ' Y ')'
	INDENT()
	BRANCH(N)
	UNINDENT()
*	here if one label missing!
DOCMP2L	LIVE = 1					:(RETURN)
EDOCMP2

****************************************************************
*	boolean two-way

	DEFINE("DOBOOL(B,F,T)")				:(EDOBOOL)
DOBOOL	IDENT(T)					:S(DOBOOL2)
* here with label for true
	IDENT(F,T)					:S(DOBOOL3)
	OUTPUT = IND 'if (' B ')'
	INDENT()
	BRANCH(T)
	UNINDENT()
	IDENT(F)					:S(DOBOOLL)
	OUTPUT = IND 'else'
	INDENT()
	BRANCH(F)
	UNINDENT()					:(RETURN)

* here with no label for true
DOBOOL2	IDENT(F)					:S(DOBOOL3)
	OUTPUT = IND 'if (!' B ')'
	INDENT()
	BRANCH(F)
	UNINDENT()
*	here if one label missing!
DOBOOLL	LIVE = 1					:(RETURN)

* both have same label.  eval B for side effects!
DOBOOL3	OUTPUT = IND B ';'
	IDENT(T)					:S(RETURN)
	BRANCH(T)					:(RETURN)
EDOBOOL

****************************************************************
*	descriptors

**************** helper for descr/spec indirect access 

	DEFINE("PLUS(X,Y)")				:(EPLUS)
PLUS	PLUS = IDENT(Y,'0') X				:S(RETURN)
	PLUS = X ' + ' Y				:(RETURN)
EPLUS

****************
	DEFINE("D(V)")					:(ED)
D	D = 'D(' V ')'					:(RETURN)
ED

****************************************************************
* access to descriptor fields

	DEFINE("RV(V)")					:(ERV)
RV	RV = 'D_RV(' V ')'				:(RETURN)
ERV
****************
	DEFINE("D_A(V)")				:(ED_A)
D_A	D_A = 'D_A(' V ')'				:(RETURN)
ED_A
****************
	DEFINE("D_F(V)")				:(ED_F)
D_F	D_F = 'D_F(' V ')'				:(RETURN)
ED_F
****************
	DEFINE("D_V(V)")				:(ED_V)
D_V	D_V = 'D_V(' V ')'				:(RETURN)
ED_V
****************
	DEFINE("D_PTR(V)")				:(ED_PTR)
D_PTR	D_PTR = 'D_PTR(' V ')'				:(RETURN)
ED_PTR
*
****************
* descriptor at indirect address

	DEFINE("INDD(X,Y)")				:(EINDD)
INDD	INDD = D(PLUS(X,Y))				:(RETURN)
EINDD

****************
* fetch v field of descriptor at indirect address

	DEFINE("INDD_A(X,Y)")				:(EINDD_A)
INDD_A	INDD_A = D_A( PLUS(X,Y) )			:(RETURN)
EINDD_A

****************
* clear descriptor V (T) & F fields

	DEFINE("CLEAR_D_VF(V)")				:(ECLEAR_D_VF)
CLEAR_D_VF
	OUTPUT = IND D_F(V) ' = ' D_V(V) ' = 0;'	:(RETURN)
ECLEAR_D_VF

****************************************************************
*	specifiers

****************
	DEFINE("S_L(V)")				:(ES_L)
S_L	S_L = 'S_L(' V ')'				:(RETURN)
ES_L
****************
	DEFINE("S_O(V)")				:(ES_O)
S_O	S_O = 'S_O(' V ')'				:(RETURN)
ES_O
****************
	DEFINE("SPEC(V)")				:(ESPEC)
SPEC	SPEC = '_SPEC(' V ')'				:(RETURN)
ESPEC

****************************************************************

	DEFINE("MKPROC(PROC)STAT")			:(EMKPROC)
MKPROC	DIFFER(ISPROC<PROC>)				:S(RETURN)
	STATIC.H = IDENT(GLOBAL<PROC>) 'static ' PROCTYPE ' ' PROC ' __P((ret_t));'
	THAW(ISPROC)
	ISPROC<PROC> = 1
	FREEZE(ISPROC)					:(RETURN)
EMKPROC

****************************************************************
*
****************************************************************
*	main program

	DATE = DATE()

*	PROC.H = '/* generated from ' SILPATH ' by genc.sno on ' DATE ' */'
	PROC.H = '/* generated from ' SILPATH ' by genc.sno */'
	PROC.H =

	OUTPUT = '/* generated from ' SILPATH ' by genc.sno on ' DATE ' */'
	OUTPUT =

	IDENT(INLINE)					:S(NOINLINE)
	OUTPUT = '#define INLINING'
	OUTPUT =
NOINLINE

****************
*	read  list of procs referenced from data (DESCRs)
	DIFFER(MAINBOL)					:S(MB3)
*	XXX check for success!
	INPUT(.GLOB,3,"globals")			:S(GLOBLOP)F(GLOBERR)
MB3	INPUT(.GLOB,3,,"globals")			:S(GLOBLOP)
GLOBERR	TERMINAL = "FATAL: could not open global.procs"	:(FATAL)

GLOBLOP	PROC = GLOB					:F(GLOBEND)
	output = "glob: " proc
*	skip comments!
	PROC '*'					:S(GLOBLOP)
	GLOBAL<PROC> = 1
	PROC.H = 'extern ' PROCTYPE ' ' PROC ' __P((ret_t));'
*	make sure it's a proc!
	MKPROC(PROC)					:(GLOBLOP)
GLOBEND	FREEZE(GLOBAL)
	FREEZE(ISPROC)
	DETACH(.GLOB)
	ENDFILE(3)
****************
*	read gendep output!
	DIFFER(MAINBOL)					:S(MB4)
*	XXX check for success!
	INPUT(.PPP,4,"procs")				:S(PPPLOP)F(PROCERR)
MB4	INPUT(.PPP,4,,"procs")				:S(PPPLOP)
PROCERR	TERMINAL = "FATAL: could not open procs file"	:(FATAL)

PPPLOP	PROC = PPP					:F(PPPEND)
*	skip comments!
	PROC '*'					:S(PPPLOP)
	MKPROC(PROC)					:(PPPLOP)
PPPEND	DETACH(.PPP)
	ENDFILE(4)

****************************************************************
*	patterns

	LINE_PAT = (TNUL . LBL) WS (TNUL . OP) WS 

	QS_ARG_PAT = "'" BREAK("'") . ARGS "'"
	NQS_ARG_PAT = TOK . ARGS
	BAL_ARG_PAT = (LP BAL RP) . ARG
	NBAL_ARG_PAT = ARGP . ARG

	OUTPUT_PAT1 = LP BREAK(RP) . L RP

****************************************************************
TOP0
*	current indent level
	ILEVEL = 0

	IND =

*	not in a block comment
	BLOCK =
	LIVE = 1
	LN = 0
*
*	here for each line of input file
TOP	&INPUT = 1
	LINE = INPUT					:F(EOF)
	&INPUT = 0
	LN = LN + 1
	ORIG = LINE
	LINE = LINE SP
	LBL = 
	OP =
	ARGS =
	COMM =

*	check for CPP directive
	ORIG "#"					:F(NOTCPP)
	OUTPUT = ORIG					:(TOP)

*	check for start of c-code copy
NOTCPP	ORIG "%{"					:F(NOTCOPY)
	OUTPUT = IND '{'
	INDENT()

*	here if copying C code
	&INPUT = 1
DOCOPY	LN = LN + 1
	LINE = INPUT					:F(EOF)
*	check for end
	LINE "%}"					:S(ECOPY)
*	TERMINAL = "COPY: " LINE
	OUTPUT = IND LINE				:(DOCOPY)

*	here at end of c-copy
ECOPY	UNINDENT()
	OUTPUT = IND '}'				:(TOP)

*	a comment?
NOTCOPY	LINE '*'					:F(NOTCOMM)

*	here with comment. see if magic dead end indicator!
	LINE '*_'					:F(BLOCK)
*	dead end; clear live code flag
	LIVE =
	CFLUSH()
*	flush out block comment before outputting our comment!!
	OUTPUT = IND BC '_' EC				:(TOP)

*	here to start a block comment
BLOCK
	DIFFER(BLOCK_COMMENTS)				:F(TOP)
	OUTPUT = IDENT(BLOCK) BBC
	OUTPUT = SP LINE
	BLOCK = 1					:S(TOP)

****************
*	here if not a comment, parse label and opcode

NOTCOMM	LINE LINE_PAT =

	ARGC = 0
	ARGV = ARRAY(10)

*	check for quoted string arg
	LINE QS_ARG_PAT =				:F(NQARGS)
	ARGV<0> = ARGS
	ARGC = 1					:S(PARSED)

*	here with args NOT a quoted string
NQARGS	LINE NQS_ARG_PAT =

*	split args!
DISARGS	ARGS BAL_ARG_PAT =				:S(GOTARG)
	ARGS NBAL_ARG_PAT =

GOTARG	ARGC = ARGC + 1

	ARGV<ARGC> = ARG
	ARGS COMMA =					:S(DISARGS)
EARGS
*
*	here with arg list parsed into ARGV
PARSED	LINE WS =
	COMM = LINE

	DIFFER(NOCODE<OP>)				:S(TOP)

	IDENT(LBL)					:S(DISPATCH)
*	here with a label
	IDENT(ISPROC<LBL>)				:S(NOTPROC)

*	label is start of a proc (per gendep)
	BPROC(LBL)					:(DISPATCH)

*	label is not start of a proc
NOTPROC	IDENT(INPROC)					:S(DISPATCH)
*	in a procedure; end block comment,  output label
	CFLUSH()
	OUTPUT = L_ LBL ':'
*	OLABEL = 1
	LIVE = 1
	LLBL = LBL

****************
*	dispatch on op field after outputting comments, #line etc.
DISPATCH

* test for all options at once!!
	IDENT(COMM POUND_LINE)				:S(DISPATCH2)

*	have end of line comment?
	IDENT(COMM)					:S(NOCOMM)
*	end of line comments enabled?
	IDENT(EOL_COMMENTS)				:S(NOCOMM)
	CFLUSH()
	OUTPUT = IND BC SP COMM EC

NOCOMM	IDENT(POUND_LINE)				:S(NOHASH)

*	output un*x line indicator (see comments at top)
	OUTPUT = DIFFER(INPROC) '# line ' LN ' "' SILPATH '"'
NOHASH

DISPATCH2
*	TERMINAL = OP
*	OLABEL =
							:($('X' OP))
 
****************
*	null op?!
X
*	other ops with null actions (see also  NOCODE table)
*
* procedure-ness dtermined by ISPROC table
XXPROC
XPROC
*	TERMINAL = TAB LBL
XLHERE							:(OPDONE)
*
****************************************************************
*	data movement

****************
*	SIL MOVD (MOVDD) MACRO
XMOVD	OUTPUT = IND D(ARGV<1>) ' = ' D(ARGV<2>) ';'	:(OPDONE)

****************
*	SIL MOVDIC (TRANDC) MACRO 10/27/93
XMOVDIC	OUTPUT = IND INDD(D_A(ARGV<1>), ARGV<2>) ' = '
+		     INDD(D_A(ARGV<3>), ARGV<4>) ';'	:(OPDONE)

****************
*	SIL MOVA (MOVVV) MACRO
XMOVA	OUTPUT = IND D_A(ARGV<1>) ' = ' D_A(ARGV<2>) ';' :(OPDONE)

****************
*	SIL SETAC (MOVVC) MACRO
XSETAC	X = ARGV<2>
* no fuss for simple integer
	X SPAN(DIGS) RPOS(0)				:S(XSETAC3)
* otherwise need a cast (for pointers)
	X BREAK(OPERS) ANY(OPERS)			:F(XSETAC2)
* operators present; parenthesize
	X = '(int_t) (' X ')'				:(XSETAC3)
* here with non-integer, but no operators
XSETAC2	X = '(int_t) ' X
XSETAC3	OUTPUT = IND D_A(ARGV<1>) ' = ' X ';'		:(OPDONE)

****************
*	SIL SETAV (MOVVT) MACRO
XSETAV	OUTPUT = IND D_A(ARGV<1>) ' = ' D_V(ARGV<2>) ';'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL MOVV (MOVTT) MACRO
XMOVV	OUTPUT = IND D_V(ARGV<1>) ' = ' D_V(ARGV<2>) ';' :(OPDONE)

****************
*	SIL SETVA (MOVTV) MACRO 10/25/93
* not in macros.360?!
XSETVA	OUTPUT = IND D_V(ARGV<1>) ' = ' D_A(ARGV<2>) ';' :(OPDONE)

****************
*	SIL SETVC (MOVTC) MACRO
XSETVC	OUTPUT = IND D_V(ARGV<1>) ' = ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL GETSIZ (GETIT) MACRO
XGETSIZ	OUTPUT = IND D_A(ARGV<1>) ' = ' D_V(D_A(ARGV<2>))  ';'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL SETSIZ (PUTIT) MACRO
XSETSIZ	OUTPUT = IND D_V(D_A(ARGV<1>)) ' = ' D_A(ARGV<2>) ';'
							:(OPDONE)

****************
*	SIL GETD (=) MACRO
XGETD	OUTPUT = IND D(ARGV<1>) ' = ' INDD( D_A(ARGV<2>), D_A(ARGV<3>)) ';'
							:(OPDONE)
****************
*	SIL PUTD (=) MACRO
XPUTD	OUTPUT = IND INDD( D_A(ARGV<1>), D_A(ARGV<2>) ) ' = ' D(ARGV<3>) ';'
							:(OPDONE)

****************
*	SIL GETDC (=) MACRO
XGETDC	OUTPUT = IND D(ARGV<1>) ' = ' INDD( D_A(ARGV<2>), ARGV<3>) ';'
							:(OPDONE)

****************
*	SIL PUTDC (=) MACRO
XPUTDC	OUTPUT = IND INDD( D_A(ARGV<1>), ARGV<2>) ' = ' D(ARGV<3>) ';'
							:(OPDONE)

****************
*	SIL GETAC (=) MACRO
XGETAC	OUTPUT = IND D_A(ARGV<1>) ' = ' INDD_A(D_A(ARGV<2>), ARGV<3>) ';'
								:(OPDONE)
****************
*	SIL PUTAC (=) MACRO
XPUTAC	OUTPUT = IND INDD_A(D_A(ARGV<1>), ARGV<2>) ' = ' D_A(ARGV<3>) ';'
								:(OPDONE)
****************
*	SIL PUTVC (PUTTC) MACRO 10/18/93
* XXX INDD_V??
XPUTVC	OUTPUT = IND D_V(PLUS(D_A(ARGV<1>),ARGV<2>)) ' = ' D_V(ARGV<3>) ';'
								:(OPDONE)

****************
*	SIL BKSIZE (COMSZ) MACRO 10/27/93
XBKSIZE	OUTPUT = IND D_A(ARGV<1>) ' = X_BKSIZE(' D_A(ARGV<2>) ');'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL SETSP (MOVQQ) MACRO
XSETSP	OUTPUT = IND SPEC(ARGV<1>) ' = ' SPEC(ARGV<2>) ';'	:(OPDONE)

****************
*	SIL GETLTH (COMNVZ) MACRO 10/??/93
XGETLTH	OUTPUT = IND 'D_A(' ARGV<1> ') = X_GETLTH(' ARGV<2> ');'
	CLEAR_D_VF(ARGV<1>)					:(OPDONE)

****************
*	SIL GETLG (MOVLV) MACRO
XGETLG	OUTPUT = IND D_A(ARGV<1>) ' = ' S_L(ARGV<2>) ';'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL PUTLG (MOVVL) MACRO
XPUTLG	OUTPUT = IND S_L(ARGV<1>) ' = ' D_A(ARGV<2>) ';' :(OPDONE)

****************
*	SIL SETLC (MOVLC) MACRO
XSETLC	OUTPUT = IND S_L(ARGV<1>) ' = ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL GETSPC (GETQC) MACRO
* XXX INDS??
XGETSPC	OUTPUT = IND SPEC(ARGV<1>) ' = ' SPEC(PLUS(D_A(ARGV<2>),ARGV<3>)) ';'
							:(OPDONE)

****************
*	SIL PUTSPC (PUTQC) MACRO 10/27/93
* XXX INDS??
XPUTSPC	OUTPUT = IND SPEC(PLUS(D_A(ARGV<1>),ARGV<2>)) ' = ' SPEC(ARGV<3>) ';'
							:(OPDONE)
****************************************************************
*	string ops

****************
*	SIL APDSP (APDQQ) MACRO 10/18/93
XAPDSP	OUTPUT = IND 'APDSP(' ARGV<1> ',' ARGV<2> ');'		:(OPDONE)

****************
*	SIL FSHRTN (DELQC) MACRO 10/20/93
XFSHRTN	OUTPUT = IND S_L(ARGV<1>) ' -= ' ARGV<2> ';'
	OUTPUT = IND S_O(ARGV<1>) ' += ' ARGV<2> ';'		:(OPDONE)

****************
*	SIL SHORTN (DELLC) MACRO 10/24/93
XSHORTN	OUTPUT = IND S_L(ARGV<1>) ' -= ' ARGV<2> ';'		:(OPDONE)

****************
*	SIL LOCSP (COMQNV) MACRO 10/18/93
XLOCSP	OUTPUT = IND 'X_LOCSP(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL TRIMSP (TRIMQQ) MACRO 10/27/93
XTRIMSP	OUTPUT = IND 'TRIMSP(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL SUBSP (SUBQQ) MACRO 10/27/93
XSUBSP	IDENT(ARGV<4>)					:S(XSUBSP2)
	OUTPUT = IND 'if (' S_L(ARGV<3>) ' < ' S_L(ARGV<2>) ')'
	INDENT()
	BRANCH(ARGV<4>)
	UNINDENT()
XSUBSP2
* XXX copy A, F, O and V seperately? (not needed unless ARGV<1>==ARGV<2>)
	OUTPUT = DIFFER(ARGV<1>,ARGV<3>)
+			IND SPEC(ARGV<1>) ' = ' SPEC(ARGV<3>) ';'
	OUTPUT = IND S_L(ARGV<1>) ' = ' S_L(ARGV<2>) ';'
	IDENT(ARGV<5>)					:S(OPDONEL)
	BRANCH(ARGV<5>)					:S(OPDONE)

****************
*	SIL REMSP (COMSQ) MACRO 10/28/93
XREMSP	OUTPUT = IND 'X_REMSP(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ');'
							:(OPDONE)
*
****************************************************************
*	code trees


****************
*	SIL INSERT (INSNOD) MACRO 10/27/93
XINSERT	OUTPUT = IND 'INSERT(' ARGV<1> ',' ARGV<2> ');' :(OPDONE)

****************
*	SIL ADDSIB (APDSIB) MACRO 10/27/93
XADDSIB	OUTPUT = IND 'ADDSIB(' ARGV<1> ',' ARGV<2> ');' :(OPDONE)

****************
*	SIL ADDSON (APDSON) MACRO 10/27/93
XADDSON	OUTPUT = IND 'ADDSON(' ARGV<1> ',' ARGV<2> ');' :(OPDONE)

****************************************************************
*	integer math

****************
*	SIL SUM (ADDVV) MACRO
XSUM	OP = '+'					:(INT_OP)

****************
*	SIL SUBTRT (SUBVV) MACRO
XSUBTRT	OP = '-'					:(INT_OP)

****************
*	SIL MULT (MPYVV) MACRO
* MPYI in macros.360?
XMULT	OP = '*'					:(INT_OP)

****************
*	SIL DIVIDE (DIVVV) MACRO
XDIVIDE	OP = '/'					
	IDENT(ARGV<4>)					:S(INT_OP)
	OUTPUT = IND 'if (' D_A(ARGV<3>) ' == 0)'
	INDENT()
	BRANCH(ARGV<4>)
	UNINDENT()					:(INT_OP)
*
****************
*	handle integer ops
INT_OP	X = D_A(ARGV<1>)
	Y = D_A(ARGV<2>)
	Z = D_A(ARGV<3>)
	OUTPUT = DIFFER(ARGV<4>) IND 'CLR_MATH_ERROR();'
	IDENT(X,Y)					:S(INT_OP2)
	IDENT(X,Z)					:S(INT_OP3)
*	3-way; copy data-type, flags to output
	OUTPUT = IND D(ARGV<1>) ' = ' D(ARGV<2>) ';'
INT_OP2	OUTPUT = IND X ' ' OP '= ' Z ';'		:(INT_OP4)

*	here when 'x' and 'z' are identical (~13 occurances)
*	copy type/flags "manually"
INT_OP3	OUTPUT = IND X ' = ' Y ' ' OP ' ' Z ';'
	OUTPUT = IND D_F(ARGV<1>) ' = ' D_F(ARGV<2>) ';'
	OUTPUT = IND D_V(ARGV<1>) ' = ' D_V(ARGV<2>) ';'

INT_OP4	IDENT(ARGV<4>)					:S(INT_OP5)
	OUTPUT = IND 'if (MATH_ERROR())'
	INDENT()
	BRANCH(ARGV<4>)
	UNINDENT()
INT_OP5	IDENT(ARGV<5>)					:S(OPDONE)
	BRANCH(ARGV<5>)					:(OPDONE)

****************************************************************
*	other integer arithmetic ops

****************
*	SIL MULTC (MPYVC) MACRO
* MPYC in macros.360?
XMULTC	IDENT(ARGV<1>,ARGV<2>)				:S(XMULTC2)
	OUTPUT = IND D_A(ARGV<1>) ' = ' D_A(ARGV<2>) ';'
XMULTC2	OUTPUT = IND D_A(ARGV<1>) ' *= ' ARGV<3> ';'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL ADDLG (ADDLV) MACRO 10/27/93
XADDLG	OUTPUT = IND S_L(ARGV<1>) ' += ' D_A(ARGV<2>) ';' :(OPDONE)

****************
*	SIL INCRA (INCVC) MACRO
XINCRA	OUTPUT = IND D_A(ARGV<1>) ' += ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL ADJUST (RELPTR) MACRO 11/1/93
XADJUST	OUTPUT = IND D_A(ARGV<1>) ' = '
+		D_A(ARGV<3>) ' + ' D_A(D_A(ARGV<2>)) ';' :(OPDONE)

****************
*	SIL INCRV (INCTC) MACRO
XINCRV	OUTPUT = IND D_V(ARGV<1>) ' += ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL DECRA (DECVC) MACRO
XDECRA	OUTPUT = IND D_A(ARGV<1>) ' -= ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL MNSINT (NEGV) MACRO
XMNSINT	OUTPUT = DIFFER(ARGV<3>) IND 'CLR_MATH_ERROR();'
	OUTPUT = DIFFER(ARGV<1>,ARGV<2>) IND D(ARGV<1>) ' = ' D(ARGV<2>) ';'
	OUTPUT = IND D_A(ARGV<1>) ' = -' D_A(ARGV<1>) ';'
	IDENT(ARGV<3>)					:S(XMNSIN2)
	OUTPUT = IND 'if (MATH_ERROR())'
	INDENT()
	BRANCH(ARGV<3>)
	UNINDENT()
XMNSIN2	IDENT(ARGV<4>)					:S(OPDONE)
	BRANCH(ARGV<4>)					:(OPDONE)

****************
*	SIL INTRL (CVTRI) MACRO
XINTRL	OUTPUT = IND RV(ARGV<1>) ' = (real_t)' D_A(ARGV<2>) ';'
	OUTPUT = IND D_F(ARGV<1>) ' = 0;'
	OUTPUT = IND D_V(ARGV<1>) ' = R;'		:(OPDONE)
*
****************************************************************
*	real arithmetic ops

****************
*	SIL ADREAL (ADDRVV) MACRO
XADREAL	ROP = '+'					:(REALOP)

****************
*	SIL DVREAL (DIVRVV) MACRO
XDVREAL	ROP = '/'					:(REALOP)

****************
*	SIL MPREAL (MPYRVV) MACRO
XMPREAL	ROP = '*'					:(REALOP)

****************
*	SIL SBREAL (SUBRVV) MACRO
XSBREAL	ROP = '-'					:(REALOP)

****************
*	handle real ops!
REALOP	OUTPUT = DIFFER(ARGV<4>) IND 'CLR_MATH_ERROR();'
	X = RV(ARGV<1>)
	Y = RV(ARGV<2>)
	Z = RV(ARGV<3>)
	IDENT(X,Y)					:S(REALOP2)
	IDENT(X,Z)					:S(REALOP3)
*	3-way; copy data-type, flags to output
	OUTPUT = IND D(ARGV<1>) ' = ' D(ARGV<2>) ';'
REALOP2	OUTPUT = IND X ' ' ROP '= ' Z ';'		:(REALOP4)

*	here when 'x' and 'z' are identical (2 occurances)
*	copy type/flags "manually"
REALOP3	OUTPUT = IND X ' = ' Y ' ' ROP ' ' Z ';'
	OUTPUT = IND D_F(ARGV<1>) ' = ' D_F(ARGV<2>) ';'
	OUTPUT = IND D_V(ARGV<1>) ' = ' D_V(ARGV<2>) ';'

* common tail; check if any branch labels
REALOP4	IDENT(ARGV<4>)					:S(REALOP5)
	OUTPUT = IND 'if (RMATH_ERROR(' RV(ARGV<1>) '))'
	INDENT()
	BRANCH(ARGV<4>)
	UNINDENT()
REALOP5	IDENT(ARGV<5>)					:S(OPDONE)
	BRANCH(ARGV<5>)					:(OPDONE)

****************
*	SIL MNREAL (NEGRV) MACRO
* can never fail!
XMNREAL	OUTPUT = DIFFER(ARGV<1>,ARGV<2>) IND D(ARGV<1>) ' = ' D(ARGV<2>) ';'
	OUTPUT = IND RV(ARGV<1>) ' = -' RV(ARGV<1>) ';'	:(OPDONE)

****************
*	SIL RLINT (CVTIR) MACRO
XRLINT	OUTPUT = DIFFER(ARGV<3>) IND 'CLR_MATH_ERROR();'
	OUTPUT = IND D_A(ARGV<1>) ' = (int_t) ' RV(ARGV<2>) ';'
	OUTPUT = IND D_F(ARGV<1>) ' = 0;'
	OUTPUT = IND D_V(ARGV<1>) ' = I;'
	IDENT(ARGV<3>)					:S(RLINT2)
	OUTPUT = IND 'if (MATH_ERROR())'
	INDENT()
	BRANCH(ARGV<3>)
	UNINDENT()
RLINT2	IDENT(ARGV<4>)					:S(OPDONE)
	BRANCH(ARGV<4>)					:(OPDONE)
*
***************************************************************
*	flag bits

****************
*	SIL SETF (ADDF) MACRO
XSETF	OUTPUT = IND D_F(ARGV<1>) ' |= ' ARGV<2> ';'	:(OPDONE)

****************
*	SIL RESETF (CLRF) MACRO
XRESETF	OUTPUT = IND D_F(ARGV<1>) ' &= ~(' ARGV<2> ');' :(OPDONE)

****************
*	SIL TESTF (=) MACRO
XTESTF	T = '(' D_F(ARGV<1>) ' & ' ARGV<2> ')'
	DOBOOL(T, ARGV<3>, ARGV<4>)			:(OPDONE)

****************
*	SIL SETFI (ADDFI) MACRO
XSETFI	OUTPUT = IND D_F(D_A(ARGV<1>)) ' |= ' ARGV<2> ';' :(OPDONE)

****************
*	SIL RSETFI (CLRFI) MACRO
XRSETFI	OUTPUT = IND D_F(D_A(ARGV<1>)) ' &= ~(' ARGV<2> ');' :(OPDONE)

****************
*	SIL TESTFI (=) MACRO
XTESTFI	T = '(' D_F(D_A(ARGV<1>)) ' & ' ARGV<2> ')'
	DOBOOL(T, ARGV<3>, ARGV<4>)			:(OPDONE)
*
****************************************************************
*	2-way comparison

****************
*	SIL VEQLC (EQLTC) MACRO
XVEQLC	DOCMP2( D_V(ARGV<1>), ARGV<2>, ARGV<3>, ARGV<4>) :(OPDONE)

****************
*	SIL VEQL (EQLTT) MACRO
XVEQL	DOCMP2( D_V(ARGV<1>), D_V(ARGV<2>), ARGV<3>, ARGV<4>) :(OPDONE)

****************
*	SIL AEQLC (EQVLC) MACRO
XAEQLC	DOCMP2( D_A(ARGV<1>), ARGV<2>, ARGV<3>, ARGV<4>) :(OPDONE)

****************
*	SIL AEQL (EQLVV) MACRO
XAEQL	DOCMP2( D_A(ARGV<1>), D_A(ARGV<2>), ARGV<3>, ARGV<4>) :(OPDONE)

****************
*	SIL AEQLIC (EQLVIC) MACRO
XAEQLIC	DOCMP2( INDD_A( D_A(ARGV<1>),ARGV<2>), '(int_t)' ARGV<3>,
+		ARGV<4>, ARGV<5>)
							:(OPDONE)

****************
*	SIL DEQL (EQLDD) MACRO
XDEQL	T = 'DCMP(' ARGV<1> ', ' ARGV<2> ')'
*	TERMINAL = 'DEQL ' ARGV<1> '/' ARGV<2> '/' ARGV<3> '/' ARGV<4>
	DOBOOL(T, ARGV<3>, ARGV<4>)			:(OPDONE)

****************
*	SIL LEQLC (EQLLC) MACRO
XLEQLC	DOCMP2( S_L(ARGV<1>), ARGV<2>, ARGV<3>, ARGV<4>) :(OPDONE)

*
****************************************************************
*	three-way comparisons

****************
*	SIL ACOMP (CMPVV) MACRO
XACOMP	DOCMP3( D_A(ARGV<1>), D_A(ARGV<2>), ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)

****************
*	SIL RCOMP (CMPRVV) MACRO
XRCOMP	DOCMP3( RV(ARGV<1>), RV(ARGV<2>), ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)
****************
*	SIL ACOMPC (CMPVC) MACRO
XACOMPC	DOCMP3( D_A(ARGV<1>), ARGV<2>, ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)
****************
*	SIL VCMPIC (CMPTIC) MACRO -- compare "assention" value in T fields!!
* XXX INDD_V??
XVCMPIC	DOCMP3( D_V(PLUS(D_A(ARGV<1>),ARGV<2>)), D_V(ARGV<3>),
+		ARGV<4>, ARGV<5>, ARGV<6>)		:(OPDONE)

****************
*	SIL CHKVAL (CMPPOS) MACRO 10/27/93
XCHKVAL	DOCMP3( PLUS(S_L(ARGV<3>),D_A(ARGV<2>)), D_A(ARGV<1>),
+		ARGV<4>, ARGV<5>, ARGV<6>)		:(OPDONE)

****************
*	SIL LCOMP (CMPLL) MACRO 10/27/93
XLCOMP	DOCMP3( S_L(ARGV<1>), S_L(ARGV<2>),
+		ARGV<3>, ARGV<4>, ARGV<5>)		:(OPDONE)

****************
*	SIL PCOMP MACRO -- from SNOBOL4+ UACOMP 8/12/2004
XPCOMP	DOCMP3( D_PTR(ARGV<1>), D_PTR(ARGV<2>), ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)

****************
*	SIL PCOMPC MACRO  -- from SNOBOL4+ UACOMPC 8/12/2004
XPCOMPC	DOCMP3( D_PTR(ARGV<1>), ARGV<2>, ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)

*
****************************************************************
*	system

****************
*	SIL COPY (=) macro
XCOPY
*	DIFFER(ARGV<1>,'MLINK')				:S(OPDONE)
*	OUTPUT = '# include "header.h"'
	OUTPUT = '# include "' REPLACE(ARGV<1>,UC,LC) '.h"'
							:(OPDONE)
****************
*	SIL INIT (INITEX) macro
XINIT	OUTPUT = IND 'init();'				:(OPDONE)

****************
*	SIL MSTIME (TIME) macro
XMSTIME	OUTPUT = IND RV(ARGV<1>) ' = mstime();'
	CLEAR_D_VF(ARGV<1>)				:(OPDONE)

****************
*	SIL DATE (=) macro 10/28/93
*	added second arg 4/2/97
XDATE	OUTPUT = IND '_DATE(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL ENDEX (TERMEX) MACRO
XENDEX	LIVE =
	OUTPUT = IND 'endex(' D_A(ARGV<1>) ');'
* Keep DECC quiet;
	OUTPUT = IND 'return 0;'			:(OPDONE)

****************
*	SIL OUTPUT (=) MACRO
XOUTPUT	OL = IND "io_printf(" D_A(ARGV<1>) "," ARGV<2>
	IDENT(ARGV<3>)					:S(XOUTEND)
	ARGV<3> OUTPUT_PAT1				:F(XOUTEND)
	OL = OL ',' L
XOUTEND	OUTPUT = OL ");"				:(OPDONE)
*
****************************************************************
*	I/O

****************
*	SIL STPRNT (PRINTQ) MACRO 10/19/93
XSTPRNT	OUTPUT = IND 'IO_PRINT(' ARGV<1> ', ' ARGV<2> ', ' ARGV<3> ');'
							:(OPDONE)

****************
*	SIL STREAD (READQ) MACRO 10/19/93
XSTREAD	OUTPUT = IND 'switch (IO_READ(' ARGV<2> ', ' ARGV<1> ')) {'
	INDENT()
	I = 0

	IDENT(ARGV<3>)					:S(XSTP1)
	I = I + 1

	UNINDENT()
	OUTPUT = IND 'case IO_EOF:'
	INDENT()
	BRANCH(ARGV<3>)

XSTP1	IDENT(ARGV<4>)					:S(XSTP2)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case IO_ERR:'
	INDENT()
	BRANCH(ARGV<4>)

XSTP2	IDENT(ARGV<5>)					:S(XSTP3)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case IO_OK:'
	INDENT()
	BRANCH(ARGV<5>)

XSTP3	UNINDENT()
	OUTPUT = IND '}'
	EQ(I,3)						:S(OPDONE)F(OPDONEL)

****************
*	SIL REWIND (=) MACRO 10/27/93
XREWIND	OUTPUT = IND 'io_rewind(' D_A(ARGV<1>) ');'	:(OPDONE)

****************
*	SIL ENFILE (=) MACRO 10/27/93
XENFILE	F = 'io_endfile'
IOFUN1	X = F '(' D_A(ARGV<1>) ')'
	DOBOOL(X,ARGV<2>,ARGV<3>)			:(OPDONE)

****************
*	SIL BKSPCE (=) MACRO 10/27/93
XBKSPCE	OUTPUT = IND 'io_backspace(' D_A(ARGV<1>) ');'	:(OPDONE)

****************
*	SIL XOPENI extension 11/10/93; RIP 10/16/96
*XXOPENI F = 'IO_OPENI'					:(FSFUN2)

****************
*	SIL XOPENO extension 11/10/93; RIP 10/16/96
*XXOPENO F = 'IO_OPENO'					:(FSFUN2)

****************
*	SIL XECOMP extension 11/10/93
XXECOMP	OUTPUT = IND 'io_ecomp();'			:(OPDONE)

****************
*	SIL XRAISP extension 5/24/94
* args: SPEC
XXRAISP	OUTPUT = IND 'RAISE1(' ARGV<1> ');'		:(OPDONE)

****************
*	SIL XINCLD extension 6/12/94
*		expanded to 3-way return 2/22/2002!
* args: UNIT, SPEC
XXINCLD	OUTPUT = IND 'switch (IO_INCLUDE(' ARGV<1> ', ' ARGV<2> ')) {'
	INDENT()
	I = 0

	IDENT(ARGV<3>)					:S(XXINC1)
	I = I + 1

	UNINDENT()
	OUTPUT = IND 'case INC_FAIL:'
	INDENT()
	BRANCH(ARGV<3>)

XXINC1	IDENT(ARGV<4>)					:S(XXINC2)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case INC_SKIP:'
	INDENT()
	BRANCH(ARGV<4>)

XXINC2	IDENT(ARGV<5>)					:S(XXINC3)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case INC_OK:'
	INDENT()
	BRANCH(ARGV<5>)

XXINC3	UNINDENT()
	OUTPUT = IND '}'
	EQ(I,3)						:S(OPDONE)F(OPDONEL)

****************
*	SIL XCALLC extension 7/19/96
* args: function, C arg list (in parens), FALSE label, TRUE label
XXCALLC	X = ARGV<1> ARGV<2>
	DOBOOL(X,ARGV<3>,ARGV<4>)			:(OPDONE)
****************
*	SIL VCOMPC (snobol4+ extension) 8/26/96
* args: descr, constant, labels
XVCOMPC	DOCMP3( D_V(ARGV<1>), ARGV<2>, ARGV<3>,  ARGV<4>, ARGV<5>)
							:(OPDONE)
****************
*	SIL NANCHK (snobol4+ extension) 8/26/96
XNANCHK	X = 'isnan(' RV(ARGV<1>) ')'
	DOBOOL(X,ARGV<2>,ARGV<3>)			:(OPDONE)

*
****************************************************************
*	stack operations

****************
*	SIL PSTACK (STKPTR) macro
XPSTACK	OUTPUT = IND 'PSTACK(' ARGV<1> ');'		:(OPDONE)

****************
*	SIL ISTACK (INITST) macro
XISTACK	OUTPUT = IND 'ISTACK();'			:(OPDONE)

****************
*	SIL PUSH (PUSHD) macro
XPUSH	XAPPLY('PUSH',ARGV<1>)				:(OPDONE)

****************
*	SIL POP (POPD) macro
XPOP	XAPPLY('POP',ARGV<1>)				:(OPDONE)

****************
*	SIL SPUSH (PUSHQ) macro
XSPUSH	XAPPLY('SPUSH',ARGV<1>)				:(OPDONE)

****************
*	SIL SPOP (POPQ) macro
XSPOP	XAPPLY('SPOP',ARGV<1>)				:(OPDONE)

****************
*	SIL RCALL (=) macro
* val, proc, arg(s), ret(s)
XRCALL	VAL = 'NORET'
	CALLGRAPH = ARGV<2> TAB INPROC
	IDENT(ARGV<1>)					:S(NOVAL)
	VAL = ARGV<1>

NOVAL	ALTS = ARGV<4>
	OUTPUT = IND 'SAVSTK();'
	IDENT(ARGV<3>)					:S(NOARGS)
	XRAPPLY('PUSH',ARGV<3>)

NOARGS	DIFFER(ALTS)					:F(NOALT2)

*	here with list of alternate rets
	ALTS LP						:S(NOALT3)
*	deal with singleton (no parens)
	ALTS = LP ALTS RP
NOALT3	SELBRA( ARGV<2> '(' VAL ')', ALTS )		:(ERCALL)

*	no alternate return points
NOALT2	OUTPUT = IND ARGV<2> '(' VAL ');'
ERCALL							:(OPDONEL)
*
****************
*	SIL RRTURN (=) macro
XRRTURN	IDENT(ARGV<1>)					:S(RRTURN1)
*	OUTPUT = IND 'if (retval)'
*	INDENT()
	OUTPUT = IND 'D(retval) = ' D(ARGV<1>) ';'
*	UNINDENT()
RRTURN1	ALT = '0'
	ALT = DIFFER(ARGV<2>) ARGV<2>
	OUTPUT = IND 'RETURN(' ALT ')'
	LIVE =						:(OPDONE)

****************************************************************
*	data conversions

****************
*	SIL INTSPC (CVTSI) MACRO 10/24/93
XINTSPC	OUTPUT = IND 'INTSPC(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL REALST (CVTSR) MACRO 10/24/93
XREALST	OUTPUT = IND 'REALST(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL SPCINT (CVTIS) MACRO 10/24/93
XSPCINT	T = 'SPCINT(' ARGV<1> ',' ARGV<2> ')'
	DOBOOL(T, ARGV<3>, ARGV<4>)			:(OPDONE)

****************
*	SIL SPREAL (CVTRS) MACRO 10/24/93
XSPREAL	T = 'SPREAL(' ARGV<1> ',' ARGV<2> ')'
	DOBOOL(T, ARGV<3>, ARGV<4>)			:(OPDONE)

****************************************************************
*	branches

****************
*	SIL BRANCH (=) macro
XBRANCH	BRANCH(ARGV<1>)					:(OPDONE)

****************
*	SIL BRANIC (BRANIN) macro
XBRANIC OUTPUT = IND 'BRANCH( ((func_t) ('
+		INDD_A( D_A(ARGV<1>), ARGV<2>) ')))'
	LIVE =
							:(OPDONE)

****************
*	SIL SELBRA (BRANLV) macro
XSELBRA	SELBRA( D_A(ARGV<1>), ARGV<2>)			:(OPDONE)

*
****************************************************************
*	pseudo-ops

****************
*	SIL END (=) macro
*	SIL XECODE extension (end of code) 2/18/2002
XXECODE
XEND	IDENT(INPROC)					:S(OPDONE)
	IDENT(LIVE)					:S(XEND2)
* XXX just call EPROC(NULL)?
	OUTPUT = IND '/* PANIC? */'
	OUTPUT = IND ';'
XEND2	UNINDENT()
	OUTPUT = '}'
	t = TIME()
	st = &STEXEC
	TMGC = t - &GCTIME
	LOOPS = LOOPS + 1

* punt if one more loop might overflow STEXEC:
	GE((st / LOOPS), (&MAXINT / (LOOPS + 1)))	:S(XEND3)

* calculate Kst/sec, output time every 5 seconds:
	MS = CONVERT(TMGC + 0.5, "INTEGER")
	SEC = MS / 1000
	NTDIV5 = SEC / 5
	EQ(TDIV5, NTDIV5)				:S(AGAIN)
	TDIV5 = NTDIV5

	TDISP = ((NE(SEC, 0) SEC 's'), (MS 'ms'))
	OSS = SS
	SS = CONVERT((st / t) + 0.5, 'INTEGER')

	TTY = LPAD(LOOPS,4) ' loops; ' 
+		LPAD(TDISP,8) '; ' LPAD(st / 1000,7) ' Kstmts; '
+		SS  ' Kst/sec'

* average at least ten loops:
	LT(LOOPS, 10)					:S(AGAIN)

* at least MIN_SEC secconds:
	LT(SEC, MIN_SEC)				:S(AGAIN)
* no more than MAX_SEC seconds
	GE(SEC, MAX_SEC)				:S(XEND3)

* at least MIN_STMT statements
	LT(st, MIN_STMT)				:S(AGAIN)
* no more than MAX_STMT statements
*	TTY = 'st: ' st ' / ' MAX_STMT
	GE(st, MAX_STMT)				:S(XEND3)

	IDENT(OSS)					:S(AGAIN)

* quit if same ST/SEC as last
	EQ(OSS, SS)					:S(XEND3)

* quit if within 2/10ths of a percent of last
	percent = 0.2
	ratio = (1.0 * SS) / OSS
*	TTY = 'ratio: ' ratio '(' SS '/' OSS ')'
	GT(ratio, 1 + percent / 100)			:S(AGAIN)
	GT(ratio, 1 - percent / 100)			:S(XEND3)

AGAIN	REWIND(5)
	COLLECT()
	:(TOP0)

XEND3
*	TTY = LOOPS ' loops, ' t ' ms.'
*	TTY = 'GCTIME ' CONVERT(&GCTIME / 1000, 'INTEGER') 'ms'
*	TTY = s = &STEXEC
*	TTY = s / t ' kstatements/s'
		:(END)

****************
*	SIL TITLE (=) macro
* XXX would like to output block comment, but still inside previous
* function (safe to call EPROC??  It's doubtfull that last function in
* a section falls into code at top of next section)!!!
*
* just collect block comment, dump after EPROC()?
XTITLE
*	TERMINAL = +SECTION '. ' ARGS
*	table of contents is section zero!
	SECTION = SECTION + 1				:(OPDONE)

****************************************************************
*	generate library function calls

****************
*	SIL ZERBLK (CLRBLK) MACRO
XZERBLK	OUTPUT = IND 'ZERBLK(' D_A(ARGV<1>) "," D_A(ARGV<2>) ');'
							:(OPDONE)

****************
*	SIL MOVBLK (CPYBLK) MACRO 10/28/93
XMOVBLK	OUTPUT = IND 'MOVBLK(' D_A(ARGV<1>) ',' D_A(ARGV<2>) ','
+				D_A(ARGV<3>) ');'	:(OPDONE)

****************
*	SIL VARID (HASH) macro
* XXX only called once!! do it inline??
XVARID	OUTPUT = IND 'HASH(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL GETBAL (COMBAL) MACRO
XGETBAL	F = 'GETBAL'					:(FSFUN2)

****************
*	two-arg function with F/S returns
FSFUN2	X = F '(' ARGV<1> ',' ARGV<2> ')'
	DOBOOL(X,ARGV<3>,ARGV<4>)			:(OPDONE)

****************
*	SIL LOCAPT (LOCAD) MACRO 10/27/93
XLOCAPT	F = 'LOCAPT'					:(FSFUN3)

****************
*	SIL LOCAPV (LOCBD) MACRO 10/27/93
XLOCAPV	F = 'LOCAPV'					:(FSFUN3)
*
****************
*	SIL EXPINT (EXPVV) MACRO 10/27/93
XEXPINT	F = 'EXPINT'					:(FSFUN3)

****************
*	SIL EXREAL (EXPRVV) MACRO 10/27/93
XEXREAL	F = 'EXREAL'					:(FSFUN3)

****************
*	SIL LOAD (=) MACRO
XLOAD	F = '_LOAD'					:(FSFUN3)

****************
*	3-arg function with F/S returns
FSFUN3	X = F '(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ')'
	DOBOOL(X,ARGV<4>,ARGV<5>)			:(OPDONE)

****************
*	SIL LINK (=) MACRO 10/28/93
XLINK	F = 'CALLX'					:(FSFUN4)

****************
*	4-arg function with F/S returns
FSFUN4	X = F '(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ',' ARGV<4> ')'
	DOBOOL(X,ARGV<5>,ARGV<6>)			:(OPDONE)

****************
*	SIL UNLOAD (=) MACRO 10/28/93
XUNLOAD	OUTPUT = IND '_UNLOAD(' ARGV<1> ');'		:(OPDONE)

****************
*	SIL LEXCMP (CMPSS) MACRO
* use different (faster) function if testing for (in)equality!!

XLEXCMP	IDENT(ARGV<3>,ARGV<5>)				:S(LEXEQ)
	X = 'LEXCMP(' ARGV<1> ',' ARGV<2> ')'
	IDENT(ARGV<3>,ARGV<4>)				:S(LEXCMP1)
	IDENT(ARGV<4>,ARGV<5>)				:S(LEXCMP1)

* here with three-way (one call)
	OUTPUT = IND '{'
	INDENT()
	OUTPUT = IND 'int x = ' X ';'
	DOCMP3('x', '0', ARGV<3>, ARGV<4>, ARGV<5>)
	UNINDENT()
	OUTPUT = IND '}'				:(OPDONE)

* here with two-way
LEXCMP1	DOCMP3(X, '0', ARGV<3>, ARGV<4>, ARGV<5>)	:(OPDONE)

LEXEQ	F = 'LEXEQ'					:(FSFUN2)

****************
*	SIL TOP (LOCTTL) MACRO 10/27/93
XTOP	OUTPUT = IND 'TOP(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ');'
							:(OPDONE)

****************
*	SIL ORDVST (ORDNVT) MACRO 11/1/93
XORDVST	OUTPUT = IND 'ordvst();'			:(OPDONE)

****************
*	SIL RPLACE (=) MACRO 11/1/93
XRPLACE	OUTPUT = IND '_RPLACE(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ');' :(OPDONE)

*
****************************************************************
*	char streams

****************
*	SIL STREAM (=) MACRO 10/19/93
XSTREAM	OUTPUT = IND
+		'switch (STREAM(' ARGV<1> ', ' ARGV<2> ', &' ARGV<3> ')) {'
	INDENT()
	I = 0

	IDENT(ARGV<4>)					:S(XSTM1)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case ST_ERROR:'
	INDENT()
*	same label as EOS? don't output twice!!
	IDENT(ARGV<4>,ARGV<5>)				:S(XSTM1)
*	if EOS missing, see if same as STOP
	DIFFER(ARGV<5>)					:S(XSTM0)
	IDENT(ARGV<4>,ARGV<6>)				:S(XSTM2)
*	ERR label unique;
XSTM0	BRANCH(ARGV<4>)

XSTM1	IDENT(ARGV<5>)					:S(XSTM2)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case ST_EOS:'
	INDENT()
*	same lable as STOP?  don't output twice!
	IDENT(ARGV<5>,ARGV<6>)				:S(XSTM2)
	BRANCH(ARGV<5>)

XSTM2	IDENT(ARGV<6>)					:S(XSTM3)
	I = I + 1
	UNINDENT()
	OUTPUT = IND 'case ST_STOP:'
	INDENT()
	BRANCH(ARGV<6>)

XSTM3	UNINDENT()
	OUTPUT = IND '}'
*	all 3 labels not present still alive!
	EQ(I,3)						:S(OPDONE)F(OPDONEL)

****************
*	SIL PLUGTB (SETUPT) MACRO 10/28/93
XPLUGTB	OUTPUT = IND 'PLUGTB(&' ARGV<1> ',AC_' ARGV<2> ',' ARGV<3> ');'
							:(OPDONE)

****************
*	SIL CLERTB (CLEART) MACRO 10/28/93
XCLERTB	OUTPUT = IND 'clertb(&' ARGV<1> ',AC_' ARGV<2> ');'
							:(OPDONE)
*
****************************************************************
*	patterns

****************
*	SIL LINKOR (CONALT) MACRO 10/27/93
XLINKOR	OUTPUT = IND 'LINKOR(' ARGV<1> ',' ARGV<2> ');'	:(OPDONE)

****************
*	SIL MAKNOD (MAKPAT) MACRO 10/27/93
XMAKNOD	IDENT(ARGV<6>)					:S(MAKNOD5)
	OUTPUT = IND 'MAKNOD(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ','
+		ARGV<4> ',' ARGV<5> ',' ARGV<6> ');'	:(OPDONE)

MAKNOD5	OUTPUT = IND 'MAKNOD(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ','
+		ARGV<4> ',' ARGV<5> ',NULL);'		:(OPDONE)

****************
*	SIL LVALUE (COMMML) MACRO 10/27/93
XLVALUE	OUTPUT = IND 'LVALUE(' ARGV<1> ',' ARGV<2> ');' :(OPDONE)

****************
*	SIL CPYPAT (=) MACRO
XCPYPAT OUTPUT = IND 'CPYPAT(' ARGV<1> ',' ARGV<2> ',' ARGV<3> ','
+		ARGV<4> ',' ARGV<5> ',' ARGV<6> ');'	:(OPDONE)

****************************************************************
****************************************************************
*	common end of opcode processing

*	here when BRANCH() called under a conditional!!
OPDONEL	LIVE = 1

*	here when done with op processing
OPDONE							:(TOP)

****************************************************************
*	the very very very very end - Lucy Van Pelt

NOFILE	TERMINAL = "NO FILENAME ON COMMAND LINE"	:(FATAL)
BADFILE TERMINAL = "CANNOT OPEN FILE " SILPATH		:(FATAL)
EOF	TERMINAL = "FATAL: EOF on " SILPATH " before END op"
FATAL	&CODE = 1
END
